// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// V1VolumeSource Represents the source of a volume to mount.
// Only one of its members may be specified.
//
// swagger:model v1VolumeSource
type V1VolumeSource struct {

	// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
	// +optional
	AwsElasticBlockStore *V1AWSElasticBlockStoreVolumeSource `json:"awsElasticBlockStore,omitempty"`

	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
	// +optional
	AzureDisk *V1AzureDiskVolumeSource `json:"azureDisk,omitempty"`

	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
	// +optional
	AzureFile *V1AzureFileVolumeSource `json:"azureFile,omitempty"`

	// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
	// +optional
	Cephfs *V1CephFSVolumeSource `json:"cephfs,omitempty"`

	// Cinder represents a cinder volume attached and mounted on kubelets host machine.
	// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
	// +optional
	Cinder *V1CinderVolumeSource `json:"cinder,omitempty"`

	// ConfigMap represents a configMap that should populate this volume
	// +optional
	ConfigMap *V1ConfigMapVolumeSource `json:"configMap,omitempty"`

	// CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
	// +optional
	Csi *V1CSIVolumeSource `json:"csi,omitempty"`

	// DownwardAPI represents downward API about the pod that should populate this volume
	// +optional
	DownwardAPI *V1DownwardAPIVolumeSource `json:"downwardAPI,omitempty"`

	// EmptyDir represents a temporary directory that shares a pod's lifetime.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
	// +optional
	EmptyDir *V1EmptyDirVolumeSource `json:"emptyDir,omitempty"`

	// Ephemeral represents a volume that is handled by a cluster storage driver (Alpha feature).
	// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
	// and deleted when the pod is removed.
	//
	// Use this if:
	// a) the volume is only needed while the pod runs,
	// b) features of normal volumes like restoring from snapshot or capacity
	//    tracking are needed,
	// c) the storage driver is specified through a storage class, and
	// d) the storage driver supports dynamic volume provisioning through
	//    a PersistentVolumeClaim (see EphemeralVolumeSource for more
	//    information on the connection between this volume type
	//    and PersistentVolumeClaim).
	//
	// Use PersistentVolumeClaim or one of the vendor-specific
	// APIs for volumes that persist for longer than the lifecycle
	// of an individual pod.
	//
	// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
	// be used that way - see the documentation of the driver for
	// more information.
	//
	// A pod can use both types of ephemeral volumes and
	// persistent volumes at the same time.
	//
	// +optional
	Ephemeral *V1EphemeralVolumeSource `json:"ephemeral,omitempty"`

	// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
	// +optional
	Fc *V1FCVolumeSource `json:"fc,omitempty"`

	// FlexVolume represents a generic volume resource that is
	// provisioned/attached using an exec based plugin.
	// +optional
	FlexVolume *V1FlexVolumeSource `json:"flexVolume,omitempty"`

	// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
	// +optional
	Flocker *V1FlockerVolumeSource `json:"flocker,omitempty"`

	// GCEPersistentDisk represents a GCE Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
	// +optional
	GcePersistentDisk *V1GCEPersistentDiskVolumeSource `json:"gcePersistentDisk,omitempty"`

	// GitRepo represents a git repository at a particular revision.
	// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
	// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
	// into the Pod's container.
	// +optional
	GitRepo *V1GitRepoVolumeSource `json:"gitRepo,omitempty"`

	// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
	// More info: https://examples.k8s.io/volumes/glusterfs/README.md
	// +optional
	Glusterfs *V1GlusterfsVolumeSource `json:"glusterfs,omitempty"`

	// HostPath represents a pre-existing file or directory on the host
	// machine that is directly exposed to the container. This is generally
	// used for system agents or other privileged things that are allowed
	// to see the host machine. Most containers will NOT need this.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
	// ---
	// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
	// mount host directories as read/write.
	// +optional
	HostPath *V1HostPathVolumeSource `json:"hostPath,omitempty"`

	// ISCSI represents an ISCSI Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod.
	// More info: https://examples.k8s.io/volumes/iscsi/README.md
	// +optional
	Iscsi *V1ISCSIVolumeSource `json:"iscsi,omitempty"`

	// NFS represents an NFS mount on the host that shares a pod's lifetime
	// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
	// +optional
	Nfs *V1NFSVolumeSource `json:"nfs,omitempty"`

	// PersistentVolumeClaimVolumeSource represents a reference to a
	// PersistentVolumeClaim in the same namespace.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	PersistentVolumeClaim *V1PersistentVolumeClaimVolumeSource `json:"persistentVolumeClaim,omitempty"`

	// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
	PhotonPersistentDisk *V1PhotonPersistentDiskVolumeSource `json:"photonPersistentDisk,omitempty"`

	// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
	// +optional
	PortworxVolume *V1PortworxVolumeSource `json:"portworxVolume,omitempty"`

	// Items for all in one resources secrets, configmaps, and downward API
	Projected *V1ProjectedVolumeSource `json:"projected,omitempty"`

	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
	// +optional
	Quobyte *V1QuobyteVolumeSource `json:"quobyte,omitempty"`

	// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
	// More info: https://examples.k8s.io/volumes/rbd/README.md
	// +optional
	Rbd *V1RBDVolumeSource `json:"rbd,omitempty"`

	// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
	// +optional
	ScaleIO *V1ScaleIOVolumeSource `json:"scaleIO,omitempty"`

	// Secret represents a secret that should populate this volume.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
	// +optional
	Secret *V1SecretVolumeSource `json:"secret,omitempty"`

	// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
	// +optional
	Storageos *V1StorageOSVolumeSource `json:"storageos,omitempty"`

	// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
	// +optional
	VsphereVolume *V1VsphereVirtualDiskVolumeSource `json:"vsphereVolume,omitempty"`
}

// Validate validates this v1 volume source
func (m *V1VolumeSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAwsElasticBlockStore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAzureDisk(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAzureFile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCephfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCinder(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigMap(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCsi(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownwardAPI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmptyDir(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEphemeral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlexVolume(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlocker(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGcePersistentDisk(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGitRepo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGlusterfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIscsi(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePersistentVolumeClaim(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhotonPersistentDisk(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePortworxVolume(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjected(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuobyte(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRbd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScaleIO(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecret(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVsphereVolume(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1VolumeSource) validateAwsElasticBlockStore(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsElasticBlockStore) { // not required
		return nil
	}

	if m.AwsElasticBlockStore != nil {
		if err := m.AwsElasticBlockStore.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("awsElasticBlockStore")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("awsElasticBlockStore")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateAzureDisk(formats strfmt.Registry) error {
	if swag.IsZero(m.AzureDisk) { // not required
		return nil
	}

	if m.AzureDisk != nil {
		if err := m.AzureDisk.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("azureDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("azureDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateAzureFile(formats strfmt.Registry) error {
	if swag.IsZero(m.AzureFile) { // not required
		return nil
	}

	if m.AzureFile != nil {
		if err := m.AzureFile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("azureFile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("azureFile")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateCephfs(formats strfmt.Registry) error {
	if swag.IsZero(m.Cephfs) { // not required
		return nil
	}

	if m.Cephfs != nil {
		if err := m.Cephfs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cephfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cephfs")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateCinder(formats strfmt.Registry) error {
	if swag.IsZero(m.Cinder) { // not required
		return nil
	}

	if m.Cinder != nil {
		if err := m.Cinder.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cinder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cinder")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateConfigMap(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigMap) { // not required
		return nil
	}

	if m.ConfigMap != nil {
		if err := m.ConfigMap.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("configMap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("configMap")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateCsi(formats strfmt.Registry) error {
	if swag.IsZero(m.Csi) { // not required
		return nil
	}

	if m.Csi != nil {
		if err := m.Csi.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("csi")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("csi")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateDownwardAPI(formats strfmt.Registry) error {
	if swag.IsZero(m.DownwardAPI) { // not required
		return nil
	}

	if m.DownwardAPI != nil {
		if err := m.DownwardAPI.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("downwardAPI")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("downwardAPI")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateEmptyDir(formats strfmt.Registry) error {
	if swag.IsZero(m.EmptyDir) { // not required
		return nil
	}

	if m.EmptyDir != nil {
		if err := m.EmptyDir.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("emptyDir")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("emptyDir")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateEphemeral(formats strfmt.Registry) error {
	if swag.IsZero(m.Ephemeral) { // not required
		return nil
	}

	if m.Ephemeral != nil {
		if err := m.Ephemeral.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ephemeral")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ephemeral")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateFc(formats strfmt.Registry) error {
	if swag.IsZero(m.Fc) { // not required
		return nil
	}

	if m.Fc != nil {
		if err := m.Fc.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fc")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateFlexVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.FlexVolume) { // not required
		return nil
	}

	if m.FlexVolume != nil {
		if err := m.FlexVolume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexVolume")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexVolume")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateFlocker(formats strfmt.Registry) error {
	if swag.IsZero(m.Flocker) { // not required
		return nil
	}

	if m.Flocker != nil {
		if err := m.Flocker.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flocker")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flocker")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateGcePersistentDisk(formats strfmt.Registry) error {
	if swag.IsZero(m.GcePersistentDisk) { // not required
		return nil
	}

	if m.GcePersistentDisk != nil {
		if err := m.GcePersistentDisk.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gcePersistentDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gcePersistentDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateGitRepo(formats strfmt.Registry) error {
	if swag.IsZero(m.GitRepo) { // not required
		return nil
	}

	if m.GitRepo != nil {
		if err := m.GitRepo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gitRepo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gitRepo")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateGlusterfs(formats strfmt.Registry) error {
	if swag.IsZero(m.Glusterfs) { // not required
		return nil
	}

	if m.Glusterfs != nil {
		if err := m.Glusterfs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("glusterfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("glusterfs")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateHostPath(formats strfmt.Registry) error {
	if swag.IsZero(m.HostPath) { // not required
		return nil
	}

	if m.HostPath != nil {
		if err := m.HostPath.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostPath")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostPath")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateIscsi(formats strfmt.Registry) error {
	if swag.IsZero(m.Iscsi) { // not required
		return nil
	}

	if m.Iscsi != nil {
		if err := m.Iscsi.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("iscsi")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateNfs(formats strfmt.Registry) error {
	if swag.IsZero(m.Nfs) { // not required
		return nil
	}

	if m.Nfs != nil {
		if err := m.Nfs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfs")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validatePersistentVolumeClaim(formats strfmt.Registry) error {
	if swag.IsZero(m.PersistentVolumeClaim) { // not required
		return nil
	}

	if m.PersistentVolumeClaim != nil {
		if err := m.PersistentVolumeClaim.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("persistentVolumeClaim")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("persistentVolumeClaim")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validatePhotonPersistentDisk(formats strfmt.Registry) error {
	if swag.IsZero(m.PhotonPersistentDisk) { // not required
		return nil
	}

	if m.PhotonPersistentDisk != nil {
		if err := m.PhotonPersistentDisk.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("photonPersistentDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("photonPersistentDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validatePortworxVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.PortworxVolume) { // not required
		return nil
	}

	if m.PortworxVolume != nil {
		if err := m.PortworxVolume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("portworxVolume")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("portworxVolume")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateProjected(formats strfmt.Registry) error {
	if swag.IsZero(m.Projected) { // not required
		return nil
	}

	if m.Projected != nil {
		if err := m.Projected.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("projected")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("projected")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateQuobyte(formats strfmt.Registry) error {
	if swag.IsZero(m.Quobyte) { // not required
		return nil
	}

	if m.Quobyte != nil {
		if err := m.Quobyte.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quobyte")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("quobyte")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateRbd(formats strfmt.Registry) error {
	if swag.IsZero(m.Rbd) { // not required
		return nil
	}

	if m.Rbd != nil {
		if err := m.Rbd.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rbd")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rbd")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateScaleIO(formats strfmt.Registry) error {
	if swag.IsZero(m.ScaleIO) { // not required
		return nil
	}

	if m.ScaleIO != nil {
		if err := m.ScaleIO.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scaleIO")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scaleIO")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateSecret(formats strfmt.Registry) error {
	if swag.IsZero(m.Secret) { // not required
		return nil
	}

	if m.Secret != nil {
		if err := m.Secret.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secret")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secret")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateStorageos(formats strfmt.Registry) error {
	if swag.IsZero(m.Storageos) { // not required
		return nil
	}

	if m.Storageos != nil {
		if err := m.Storageos.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storageos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storageos")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) validateVsphereVolume(formats strfmt.Registry) error {
	if swag.IsZero(m.VsphereVolume) { // not required
		return nil
	}

	if m.VsphereVolume != nil {
		if err := m.VsphereVolume.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsphereVolume")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsphereVolume")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this v1 volume source based on the context it is used
func (m *V1VolumeSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAwsElasticBlockStore(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAzureDisk(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAzureFile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCephfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCinder(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigMap(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCsi(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDownwardAPI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEmptyDir(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEphemeral(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFc(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlexVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlocker(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGcePersistentDisk(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGitRepo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGlusterfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostPath(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIscsi(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNfs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePersistentVolumeClaim(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhotonPersistentDisk(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePortworxVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProjected(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQuobyte(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRbd(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScaleIO(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecret(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVsphereVolume(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1VolumeSource) contextValidateAwsElasticBlockStore(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsElasticBlockStore != nil {
		if err := m.AwsElasticBlockStore.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("awsElasticBlockStore")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("awsElasticBlockStore")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateAzureDisk(ctx context.Context, formats strfmt.Registry) error {

	if m.AzureDisk != nil {
		if err := m.AzureDisk.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("azureDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("azureDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateAzureFile(ctx context.Context, formats strfmt.Registry) error {

	if m.AzureFile != nil {
		if err := m.AzureFile.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("azureFile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("azureFile")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateCephfs(ctx context.Context, formats strfmt.Registry) error {

	if m.Cephfs != nil {
		if err := m.Cephfs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cephfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cephfs")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateCinder(ctx context.Context, formats strfmt.Registry) error {

	if m.Cinder != nil {
		if err := m.Cinder.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cinder")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cinder")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateConfigMap(ctx context.Context, formats strfmt.Registry) error {

	if m.ConfigMap != nil {
		if err := m.ConfigMap.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("configMap")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("configMap")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateCsi(ctx context.Context, formats strfmt.Registry) error {

	if m.Csi != nil {
		if err := m.Csi.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("csi")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("csi")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateDownwardAPI(ctx context.Context, formats strfmt.Registry) error {

	if m.DownwardAPI != nil {
		if err := m.DownwardAPI.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("downwardAPI")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("downwardAPI")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateEmptyDir(ctx context.Context, formats strfmt.Registry) error {

	if m.EmptyDir != nil {
		if err := m.EmptyDir.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("emptyDir")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("emptyDir")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateEphemeral(ctx context.Context, formats strfmt.Registry) error {

	if m.Ephemeral != nil {
		if err := m.Ephemeral.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ephemeral")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ephemeral")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateFc(ctx context.Context, formats strfmt.Registry) error {

	if m.Fc != nil {
		if err := m.Fc.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fc")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("fc")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateFlexVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.FlexVolume != nil {
		if err := m.FlexVolume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flexVolume")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flexVolume")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateFlocker(ctx context.Context, formats strfmt.Registry) error {

	if m.Flocker != nil {
		if err := m.Flocker.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flocker")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("flocker")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateGcePersistentDisk(ctx context.Context, formats strfmt.Registry) error {

	if m.GcePersistentDisk != nil {
		if err := m.GcePersistentDisk.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gcePersistentDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gcePersistentDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateGitRepo(ctx context.Context, formats strfmt.Registry) error {

	if m.GitRepo != nil {
		if err := m.GitRepo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gitRepo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gitRepo")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateGlusterfs(ctx context.Context, formats strfmt.Registry) error {

	if m.Glusterfs != nil {
		if err := m.Glusterfs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("glusterfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("glusterfs")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateHostPath(ctx context.Context, formats strfmt.Registry) error {

	if m.HostPath != nil {
		if err := m.HostPath.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hostPath")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hostPath")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateIscsi(ctx context.Context, formats strfmt.Registry) error {

	if m.Iscsi != nil {
		if err := m.Iscsi.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("iscsi")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("iscsi")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateNfs(ctx context.Context, formats strfmt.Registry) error {

	if m.Nfs != nil {
		if err := m.Nfs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nfs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("nfs")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidatePersistentVolumeClaim(ctx context.Context, formats strfmt.Registry) error {

	if m.PersistentVolumeClaim != nil {
		if err := m.PersistentVolumeClaim.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("persistentVolumeClaim")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("persistentVolumeClaim")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidatePhotonPersistentDisk(ctx context.Context, formats strfmt.Registry) error {

	if m.PhotonPersistentDisk != nil {
		if err := m.PhotonPersistentDisk.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("photonPersistentDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("photonPersistentDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidatePortworxVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.PortworxVolume != nil {
		if err := m.PortworxVolume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("portworxVolume")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("portworxVolume")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateProjected(ctx context.Context, formats strfmt.Registry) error {

	if m.Projected != nil {
		if err := m.Projected.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("projected")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("projected")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateQuobyte(ctx context.Context, formats strfmt.Registry) error {

	if m.Quobyte != nil {
		if err := m.Quobyte.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("quobyte")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("quobyte")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateRbd(ctx context.Context, formats strfmt.Registry) error {

	if m.Rbd != nil {
		if err := m.Rbd.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rbd")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rbd")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateScaleIO(ctx context.Context, formats strfmt.Registry) error {

	if m.ScaleIO != nil {
		if err := m.ScaleIO.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scaleIO")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("scaleIO")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateSecret(ctx context.Context, formats strfmt.Registry) error {

	if m.Secret != nil {
		if err := m.Secret.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("secret")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("secret")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateStorageos(ctx context.Context, formats strfmt.Registry) error {

	if m.Storageos != nil {
		if err := m.Storageos.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storageos")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storageos")
			}
			return err
		}
	}

	return nil
}

func (m *V1VolumeSource) contextValidateVsphereVolume(ctx context.Context, formats strfmt.Registry) error {

	if m.VsphereVolume != nil {
		if err := m.VsphereVolume.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsphereVolume")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsphereVolume")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1VolumeSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1VolumeSource) UnmarshalBinary(b []byte) error {
	var res V1VolumeSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
